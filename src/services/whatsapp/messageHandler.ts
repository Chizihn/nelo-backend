import { WhatsAppMessage, MessageContext } from "@/types/whatsapp.types";
import { UserService } from "../user/userService";
import { CardService } from "../card/cardService";
import { BasenameService } from "../blockchain/basenameService";
import { OnRampService } from "../payment/onRampService";
import { IntegratedOffRampService } from "../payment/integratedOffRampService";
import { MockFiatService } from "../payment/mockFiatService";
import { KYCService } from "../kyc/kycService";
import { PinService } from "../security/pinService";
import { flutterwaveService } from "../payment/flutterwaveService";
import { logger } from "@/utils/logger";
import { MESSAGE_TEMPLATES } from "@/config/whatsapp";
import { IntentParser } from "./intentParser";
import { ResponseBuilder } from "./responseBuilder";
import { SessionManager, UserSession } from "./sessionManager";
import { FlowHandler } from "./flowHandler";
import { WhatsAppService } from "./whatsappService";

export class MessageHandler {
  private intentParser: IntentParser;
  private responseBuilder: ResponseBuilder;
  private whatsappService: WhatsAppService;

  constructor() {
    this.intentParser = new IntentParser();
    this.responseBuilder = new ResponseBuilder();
    this.whatsappService = new WhatsAppService();
  }

  /**
   * Process incoming WhatsApp message
   */
  async processMessage(
    message: WhatsAppMessage,
    contact?: { name: string; wa_id: string }
  ): Promise<void> {
    try {
      logger.info(
        `Processing message from ${message.from}: ${message.text?.body}`
      );

      // Get or create user
      const user = await this.getOrCreateUser(message.from, contact?.name);

      // Get or create session
      const session = SessionManager.getOrCreateSession(user.id, message.from);

      // Add input validation and sanitization
      const messageText = (message.text?.body || "")
        .trim()
        .substring(0, 1000) // Limit length
        .replace(/[<>]/g, ""); // Remove potential XSS chars

      if (!messageText) {
        await this.whatsappService.sendMessage(
          message.from,
          "‚ùå Empty message received. Please try again."
        );
        return;
      }

      // Handle PIN verification
      if (SessionManager.isAwaitingPin(message.from)) {
        if (/^\d{4}$/.test(messageText)) {
          const pinResult = await FlowHandler.handlePinVerification(
            message.from,
            messageText,
            session
          );

          if (pinResult.success && pinResult.shouldProceed) {
            const transactionResult =
              await FlowHandler.processPendingTransaction(session);
            await this.whatsappService.sendMessage(
              message.from,
              transactionResult
            );
            return;
          } else {
            await this.whatsappService.sendMessage(
              message.from,
              pinResult.message
            );
            return;
          }
        } else if (messageText.toLowerCase() === "cancel") {
          SessionManager.clearAwaitingPin(message.from);
          await this.whatsappService.sendMessage(
            message.from,
            "‚ùå Transaction cancelled. Type 'help' to see available commands."
          );
          return;
        } else {
          await this.whatsappService.sendMessage(
            message.from,
            "‚ùå Please enter a valid 4-digit PIN or type 'cancel' to abort."
          );
          return;
        }
      }

      // Handle active flows
      if (SessionManager.isInFlow(message.from)) {
        let flowResponse = "";

        if (messageText.toLowerCase() === "cancel") {
          SessionManager.cancelFlow(message.from);
          flowResponse =
            "‚ùå Operation cancelled. Type 'help' to see available commands.";
        } else {
          switch (session.currentFlow) {
            case "PIN_SETUP":
              flowResponse = await FlowHandler.handlePinSetupFlow(
                message.from,
                messageText,
                session
              );
              break;
            case "KYC_VERIFICATION":
              flowResponse = await FlowHandler.handleKYCFlow(
                message.from,
                messageText,
                session
              );
              break;
            case "PIN_RESET":
              flowResponse = await FlowHandler.handlePinResetFlow(
                message.from,
                messageText,
                session
              );
              break;
            default:
              SessionManager.completeFlow(message.from);
              flowResponse = "‚ùå Unknown flow. Please try again.";
          }
        }

        await this.whatsappService.sendMessage(message.from, flowResponse);
        return;
      }

      // Create message context
      const context: MessageContext = {
        message,
        user,
        session,
        contact,
      };

      // Parse user intent
      const intent = await this.intentParser.parseIntent(
        message.text?.body || "",
        context
      );

      // Debug log for intent
      logger.info(
        `Parsed intent: ${intent.type} for message: "${messageText}"`
      );

      // Handle the intent
      const response = await this.handleIntent(intent, context);

      // Send response
      await this.whatsappService.sendMessage(message.from, response);
    } catch (error) {
      logger.error("Error processing message:", error);

      // Send error message to user
      await this.whatsappService.sendMessage(
        message.from,
        MESSAGE_TEMPLATES.ERROR_GENERIC
      );
    }
  }

  /**
   * Handle parsed intent
   */
  private async handleIntent(
    intent: any,
    context: MessageContext
  ): Promise<string> {
    const { type, data } = intent;
    const { user } = context;

    switch (type) {
      case "GREETING":
      case "HELP":
        return await this.getContextualHelp(user!);

      case "CREATE_CARD":
        return await this.handleCreateCard(user!);

      case "CHECK_BALANCE":
        return await this.handleCheckBalance(user!);

      case "LIST_CARDS":
        return await this.handleListCards(user!);

      case "VIEW_CARD":
        return await this.handleViewCard(user!);

      case "SEND_MONEY":
        return await this.handleSendMoney(user!, data);

      case "DEPOSIT":
        return await this.handleDeposit(user!);

      case "TRANSACTION_HISTORY":
        return await this.handleTransactionHistory(user!);

      case "PROFILE":
        return await this.handleProfile(user!);

      case "SET_BASENAME":
        return await this.handleSetBasename(user!, data);

      case "CHECK_BASENAME":
        return await this.handleCheckBasename(data);

      case "BUY_CNGN":
        return await this.handleBuyCngn(user!, data);

      case "WITHDRAW":
        return await this.handleWithdraw(user!, data);

      case "BANK_ACCOUNT":
        return await this.handleBankAccount(user!);

      case "SUBMIT_KYC":
        return await this.handleSubmitKYC(user!, data);

      case "BUY_USDC":
        return await this.handleBuyUSDC(user!, data);

      case "BUY_USDT":
        return await this.handleBuyUSDT(user!, data);

      case "BUY_CRYPTO":
        return await this.handleBuyCrypto(user!);

      case "BUY_AMOUNT":
        return await this.handleBuyAmount(user!, data);

      case "ADD_BANK":
        return await this.handleAddBank(user!, data);

      case "CASH_OUT":
        return await this.handleCashOut(user!, data);

      case "BUY_WITH_BANK":
        return await this.handleBuyWithBank(user!, data);

      case "CONFIRM_PAYMENT":
        return await this.handleConfirmPayment(user!, data);

      case "SETUP_PIN":
        return await this.handleSetupPin(user!);

      case "RESET_PIN":
        return await this.handleResetPin(user!);

      case "CANCEL":
        return this.handleCancel();

      default:
        logger.warn(
          `Unknown intent: ${type} for message: "${context.message.text?.body}"`
        );
        return `‚ùì I didn't understand "${context.message.text?.body}".

Type "help" to see all available commands.

*Quick commands:*
‚Ä¢ balance - Check your crypto
‚Ä¢ history - View transactions  
‚Ä¢ create card - Get virtual card
‚Ä¢ buy cngn - Buy crypto`;
    }
  }

  /**
   * Get or create user from WhatsApp number
   */
  private async getOrCreateUser(whatsappNumber: string, contactName?: string) {
    try {
      // Try to find existing user
      let user = await UserService.findByWhatsAppNumber(whatsappNumber);

      if (!user) {
        logger.info(`Creating new user for WhatsApp number: ${whatsappNumber}`);

        // Create new user
        user = await UserService.createUser(whatsappNumber);

        logger.info(`User created successfully: ${user.id}`);

        // Send personalized welcome message
        const welcomeMessage = contactName
          ? MESSAGE_TEMPLATES.PERSONALIZED_WELCOME(contactName)
          : MESSAGE_TEMPLATES.WELCOME;

        await this.whatsappService.sendMessage(whatsappNumber, welcomeMessage);
      } else {
        logger.info(`Existing user found: ${user.id}`);
      }

      return user;
    } catch (error) {
      logger.error("Error getting/creating user:", error);

      // Send user-friendly error message
      await this.whatsappService.sendMessage(
        whatsappNumber,
        "‚ùå Sorry, there was an issue setting up your account. Please try again in a few moments. If the problem persists, contact support."
      );

      throw error;
    }
  }

  /**
   * Enhanced create card with PIN and KYC checks - FIXED
   */
  private async handleCreateCard(user: any): Promise<string> {
    try {
      // Check KYC status first - FIXED to read from database
      const kycStatus = await UserService.getKYCStatus(user.id);

      if (!kycStatus.canCreateCard) {
        return `üîí *KYC Required*

To create a virtual card, you need to complete KYC first.

Type "submit kyc" to start verification.

*Why KYC?*
‚Ä¢ Security and compliance
‚Ä¢ Higher transaction limits
‚Ä¢ Access to all features

*Takes only 2 minutes!* ‚è±Ô∏è`;
      }

      // Check PIN setup
      const hasPinSetup = await PinService.hasPinSetup(user.id);
      if (!hasPinSetup) {
        return `üîê *Transaction PIN Required*

For security, you need to set up a transaction PIN before creating cards.

Type "setup pin" to secure your account.

*Why PIN?*
‚Ä¢ Protects your transactions
‚Ä¢ Prevents unauthorized access
‚Ä¢ Required for all operations

*Setup takes 1 minute!* ‚è±Ô∏è`;
      }

      const result = await CardService.createCard(user.id);

      if (result.success) {
        return `üéâ *Virtual Card Created Successfully!*

üí≥ Card Number: ****${result.data.cardNumber.slice(-4)}
üè∑Ô∏è Card Type: ${result.data.brand?.toUpperCase() || "VISA"}
üí∞ Balance: 0 cNGN (empty)
üì± Status: Active

*Next Steps:*
1. üí∞ Fund card: "buy 10000" (‚Ç¶10,000 cNGN)
2. üëÄ View details: "view card"
3. üìä Check balance: "balance"

*After funding:*
‚Ä¢ Send money: "send 1000 to alice.base.eth"
‚Ä¢ Withdraw: "withdraw 5000"

Your card is ready! üöÄ`;
      } else {
        if (
          result.error?.includes("KYC") ||
          result.error?.includes("verification")
        ) {
          return `üîí *Verification Required*

${result.error}

Type "submit kyc" to complete your verification and create your card.`;
        }
        return `‚ùå Failed to create card: ${result.error}`;
      }
    } catch (error) {
      logger.error("Error creating card:", error);
      return MESSAGE_TEMPLATES.ERROR_GENERIC;
    }
  }

  /**
   * Handle check balance intent - Multi-token support (cNGN + USDC)
   */
  private async handleCheckBalance(user: any): Promise<string> {
    try {
      // Get balances for available tokens
      const balances = {
        cngn: 0,
        usdc: 0,
        cardCount: 0,
      };

      if (user.walletAddress) {
        // Get cNGN balance
        try {
          const { CngnService } = await import("../blockchain/cngnService");
          const cngnBalance = await CngnService.getBalance(user.walletAddress);
          balances.cngn = parseFloat(cngnBalance.balance);
          logger.info(`Retrieved cNGN balance: ${balances.cngn}`);
        } catch (error) {
          logger.warn("Failed to get cNGN balance:", error);
        }

        // Get USDC balance
        try {
          const { ethers } = await import("ethers");
          const provider = new ethers.JsonRpcProvider(process.env.BASE_RPC_URL);
          const usdcContract = new ethers.Contract(
            "0x036CbD53842c5426634e7929541eC2318f3dCF7e", // Base Sepolia USDC
            ["function balanceOf(address) view returns (uint256)"],
            provider
          );
          const usdcBalance = await usdcContract.balanceOf(user.walletAddress);
          balances.usdc = parseFloat(ethers.formatUnits(usdcBalance, 6)); // USDC has 6 decimals
          logger.info(`Retrieved USDC balance: ${balances.usdc}`);
        } catch (error) {
          logger.warn("Failed to get USDC balance:", error);
        }
      }

      // Get card count
      balances.cardCount = await CardService.getCardCount(user.id);

      return this.formatMultiTokenBalanceResponse(balances);
    } catch (error) {
      logger.error("Error checking balance:", error);
      return MESSAGE_TEMPLATES.ERROR_GENERIC;
    }
  }

  /**
   * Format multi-token balance response
   */
  private formatMultiTokenBalanceResponse(balances: {
    cngn: number;
    usdc: number;
    cardCount: number;
  }): string {
    const totalValue = balances.cngn + balances.usdc * 1600; // Rough NGN conversion for display

    if (balances.cngn === 0 && balances.usdc === 0) {
      return `üí∞ *Your Portfolio*

üá≥üá¨ cNGN: 0 (‚Ç¶0)
üíµ USDC: 0 ($0)
üí≥ Active Cards: ${balances.cardCount}

*Get started:*
‚Ä¢ Buy cNGN: "buy 10000"
‚Ä¢ Buy USDC: "buy usdc"
‚Ä¢ Create card: "create card"

*Supported tokens:* cNGN (Nigerian Naira) and USDC (US Dollar) on Base Sepolia`;
    }

    let response = `üí∞ *Your Portfolio*\n\n`;

    if (balances.cngn > 0) {
      response += `üá≥üá¨ cNGN: ${balances.cngn.toLocaleString()} (‚Ç¶${balances.cngn.toLocaleString()})\n`;
    }

    if (balances.usdc > 0) {
      response += `üíµ USDC: ${balances.usdc.toLocaleString()} ($${balances.usdc.toLocaleString()})\n`;
    }

    response += `üí≥ Active Cards: ${balances.cardCount}\n\n*Available actions:*\n‚Ä¢ Send cNGN: "send 1000 to alice.base.eth"\n‚Ä¢ Send USDC: "send 50 usdc to alice.base.eth"\n‚Ä¢ Create card: "create card"\n‚Ä¢ View history: "history"`;

    return response;
  }

  /**
   * Handle list cards intent
   */
  private async handleListCards(user: any): Promise<string> {
    try {
      const cards = await CardService.getUserCards(user.id);

      if (cards.length === 0) {
        return `üì± You don't have any cards yet.

Type "create card" to get started!`;
      }

      let response = `üí≥ *Your Virtual Cards*

`;

      cards.forEach((card, index) => {
        response += `${index + 1}. Card ****${card.cardNumber.slice(-4)}
   Balance: ${card.cNGNBalance} cNGN
   Status: ${card.status}

`;
      });

      response += `*Actions:*
‚Ä¢ View card details: "view card"
‚Ä¢ Fund card: "buy cngn"
‚Ä¢ Check balance: "balance"`;

      return response;
    } catch (error) {
      logger.error("Error listing cards:", error);
      return MESSAGE_TEMPLATES.ERROR_GENERIC;
    }
  }

  /**
   * Handle view card details intent
   */
  private async handleViewCard(user: any): Promise<string> {
    try {
      const cards = await CardService.getUserCards(user.id);

      if (cards.length === 0) {
        return `üì± You don't have any cards yet.

Type "create card" to get started!`;
      }

      // Get the most recent card
      const card = cards[0];
      const cardMetadata = card.metadata as any;
      const mockData = cardMetadata?.cardData || cardMetadata;

      return `üí≥ *Your Virtual Card Details*

üé¥ Card Number: ${card.cardNumber}
üìÖ Expiry: ${mockData?.expiryMonth || "12"}/${mockData?.expiryYear || "28"}
üîí CVV: ${mockData?.cvv || "123"}
üè∑Ô∏è Type: ${mockData?.brand?.toUpperCase() || "VISA"}
üí∞ Balance: ${card.cNGNBalance} cNGN
üì± Status: ${card.status}

*Security Notice:*
‚ö†Ô∏è Keep these details private
‚ö†Ô∏è Never share CVV with anyone
‚ö†Ô∏è Use only on trusted websites

*Actions:*
‚Ä¢ Fund card: "buy cngn"
‚Ä¢ Check balance: "balance"
‚Ä¢ View transactions: "history"`;
    } catch (error) {
      logger.error("Error viewing card details:", error);
      return MESSAGE_TEMPLATES.ERROR_GENERIC;
    }
  }

  /**
   * Handle transaction history intent - FIXED
   */
  private async handleTransactionHistory(user: any): Promise<string> {
    try {
      const transactions = await CardService.getRecentTransactions(user.id, 10);

      if (transactions.length === 0) {
        return `üìä *Transaction History*

No transactions yet. Get started:

*üí∞ First Steps:*
‚Ä¢ Buy crypto: "buy cngn" or "buy 10000"
‚Ä¢ Create card: "create card"
‚Ä¢ Check balance: "balance"

*üí∏ After funding:*
‚Ä¢ Send money: "send 1000 to alice.base.eth"
‚Ä¢ Withdraw: "withdraw 5000"

Your transactions will appear here once you start! üöÄ`;
      }

      let response = `üìä *Transaction History*

`;

      transactions.forEach((tx, index) => {
        const date = new Date(tx.createdAt).toLocaleDateString();
        const time = new Date(tx.createdAt).toLocaleTimeString([], {
          hour: "2-digit",
          minute: "2-digit",
        });

        // Format transaction type
        let typeIcon = "üí∞";
        if (tx.type === "DEPOSIT" || tx.type === "ONRAMP") typeIcon = "üí∞";
        if (tx.type === "WITHDRAWAL" || tx.type === "OFFRAMP") typeIcon = "üí∏";
        if (tx.type === "TRANSFER") typeIcon = "üì§";
        if (tx.type === "PAYMENT") typeIcon = "üí≥";

        response += `${typeIcon} ${tx.type}
üíµ ${tx.amount} ${tx.currency || "cNGN"}
üìÖ ${date} ${time}
‚úÖ ${tx.status}`;

        if (tx.description) {
          response += `
üìù ${tx.description}`;
        }

        if (tx.txHash) {
          response += `
üîó ${tx.txHash.slice(0, 10)}...`;
        }

        response += `

`;
      });

      response += `*Actions:*
‚Ä¢ Buy more: "buy cngn"
‚Ä¢ Send money: "send [amount] to [address]"
‚Ä¢ Check balance: "balance"`;

      return response;
    } catch (error) {
      logger.error("Error getting transaction history:", error);
      return MESSAGE_TEMPLATES.ERROR_GENERIC;
    }
  }

  /**
   * Handle Submit KYC - Updated name and flow
   */
  private async handleSubmitKYC(user: any, data: any): Promise<string> {
    try {
      const kycStatus = await UserService.getKYCStatus(user.id);

      if (kycStatus.verified) {
        return `‚úÖ *KYC Already Completed*

Your identity is already verified!
Status: ${kycStatus.level}

You can now:
‚Ä¢ Create virtual cards: "create card"
‚Ä¢ Buy crypto: "buy cngn"
‚Ä¢ Send money: "send [amount] to [address]"

${
  (await PinService.hasPinSetup(user.id))
    ? 'Type "create card" to get started! üöÄ'
    : 'Set up your PIN first: "setup pin"'
}`;
      }

      // Start KYC flow
      SessionManager.startFlow(user.whatsappNumber, "KYC_VERIFICATION");

      return `üÜî *Submit KYC - Identity Verification*

To comply with regulations and secure your account, I need to verify your identity.

*Benefits after verification:*
‚úÖ Create virtual cards
‚úÖ Higher transaction limits  
‚úÖ Buy/sell crypto
‚úÖ Send money globally

Please enter your *full name* (First Last):
Example: "John Doe"`;
    } catch (error) {
      logger.error("Error handling KYC verification:", error);
      return MESSAGE_TEMPLATES.ERROR_GENERIC;
    }
  }

  /**
   * Handle buy cNGN intent (on-ramp) - Improved UX
   */
  private async handleBuyCngn(user: any, data: any): Promise<string> {
    try {
      const amount = data?.amount || "10000"; // Default 10,000 NGN
      const amountNum = parseFloat(amount);

      // Validate amount
      if (amountNum < 100) {
        return "‚ùå Minimum purchase is ‚Ç¶100";
      }

      if (amountNum > 1000000) {
        return "‚ùå Maximum purchase is ‚Ç¶1,000,000";
      }

      // Use IntegratedOnRampService for complete flow
      const { IntegratedOnRampService } = await import(
        "../payment/integratedOnRampService"
      );

      const result = await IntegratedOnRampService.depositNGN({
        userId: user.id,
        amountNGN: amountNum,
        paymentMethod: "BANK_TRANSFER",
      });

      if (result.success) {
        return `üí∞ *Buy ${amountNum.toLocaleString()} cNGN*

üí≥ Cost: ‚Ç¶${amountNum.toLocaleString()} NGN
ü™ô You'll receive: ${amountNum.toLocaleString()} cNGN
üîó Rate: 1 NGN = 1 cNGN (no fees!)

${result.paymentInstructions}

*After making the bank transfer:*
Type "paid ${amount}" to confirm your payment

‚ö†Ô∏è Transfer the exact amount: ‚Ç¶${amountNum.toLocaleString()}`;
      } else {
        return `‚ùå Failed to create payment: ${result.error}

Try again with: "buy cngn"`;
      }
    } catch (error) {
      logger.error("Error handling buy cNGN:", error);
      return MESSAGE_TEMPLATES.ERROR_GENERIC;
    }
  }

  /**
   * Handle Buy Crypto - Show available options
   */
  private async handleBuyCrypto(user: any): Promise<string> {
    try {
      return `üí∞ *Buy Crypto*

*Available on Base Sepolia:*

üá≥üá¨ *cNGN (Nigerian Naira Token)*
‚Ä¢ Pay with: Bank transfer (NGN)
‚Ä¢ Rate: 1 NGN = 1 cNGN
‚Ä¢ Command: "buy cngn" or "buy 10000"

üíµ *USDC (USD Coin)*
‚Ä¢ Pay with: Card, Bank transfer (USD)
‚Ä¢ Rate: 1 USD = 1 USDC
‚Ä¢ Command: "buy usdc"

*Not Available:*
üí∞ USDT (Tether) - Not on Base Sepolia

*Quick Start:*
‚Ä¢ "buy 10000" - Buy ‚Ç¶10,000 cNGN (Nigerians)
‚Ä¢ "buy usdc" - Buy USD Coin (International)

*Choose based on your location:*
üá≥üá¨ Nigeria ‚Üí cNGN
üåç International ‚Üí USDC`;
    } catch (error) {
      logger.error("Error handling buy crypto:", error);
      return MESSAGE_TEMPLATES.ERROR_GENERIC;
    }
  }

  /**
   * Handle Buy Amount - Default to cNGN for Nigerian users
   */
  private async handleBuyAmount(user: any, data: any): Promise<string> {
    try {
      const amount = data?.amount || "10000";

      // Default to cNGN for amount-only purchases (Nigerian focus)
      return await this.handleBuyCngn(user, { amount });
    } catch (error) {
      logger.error("Error handling buy amount:", error);
      return MESSAGE_TEMPLATES.ERROR_GENERIC;
    }
  }

  /**
   * Handle setup PIN
   */
  private async handleSetupPin(user: any): Promise<string> {
    try {
      const hasPinSetup = await PinService.hasPinSetup(user.id);
      if (hasPinSetup) {
        return `‚úÖ *PIN Already Set Up*

Your transaction PIN is already configured.

You can:
‚Ä¢ Create cards: "create card"
‚Ä¢ Buy crypto: "buy cngn"
‚Ä¢ Reset PIN: "reset pin"

Type "create card" to get started! üöÄ`;
      }

      // Start PIN setup flow
      SessionManager.startFlow(user.whatsappNumber, "PIN_SETUP");

      return `üîê *Set Up Your Transaction PIN*

Your PIN secures all transactions and sensitive operations.

*PIN Requirements:*
‚Ä¢ Exactly 4 digits
‚Ä¢ No repeated numbers (1111, 2222, etc.)
‚Ä¢ No sequential numbers (1234, 4321, etc.)

Please enter your 4-digit PIN:`;
    } catch (error) {
      logger.error("Error handling PIN setup:", error);
      return MESSAGE_TEMPLATES.ERROR_GENERIC;
    }
  }

  /**
   * Get contextual help based on user's progress
   */
  private async getContextualHelp(user: any): Promise<string> {
    try {
      const kycStatus = await UserService.getKYCStatus(user.id);
      const hasPinSetup = await PinService.hasPinSetup(user.id);
      const cardCount = await CardService.getCardCount(user.id);

      // New user - needs KYC
      if (!kycStatus.verified) {
        return `üéâ *Welcome to Nelo!*

Your Web3 financial assistant for Nigeria üá≥üá¨

*üöÄ Let's get you started (2 minutes):*
1. Submit KYC: "submit kyc"
2. Set security PIN: "setup pin"  
3. Create virtual card: "create card"
4. Buy crypto: "buy cngn"

Type "submit kyc" to begin! ‚ú®`;
      }

      // KYC done, needs PIN
      if (!hasPinSetup) {
        return `‚úÖ *KYC Verified!*

Next step: Set up your security PIN

*üîê Security Setup:*
‚Ä¢ Set PIN: "setup pin"

*After PIN setup:*
‚Ä¢ Create card: "create card"
‚Ä¢ Buy crypto: "buy cngn"

Type "setup pin" to continue! üîí`;
      }

      // KYC + PIN done, needs card
      if (cardCount === 0) {
        return `üîí *Account Secured!*

Ready to create your virtual card?

*üí≥ Next Steps:*
‚Ä¢ Create card: "create card"
‚Ä¢ Buy crypto: "buy cngn"
‚Ä¢ Check balance: "balance"

Type "create card" to get started! üöÄ`;
      }

      // Fully set up user
      return `ü§ñ *Nelo - Ready to Use!*

*üí∞ Buy & Manage Crypto:*
‚Ä¢ buy cngn - Buy Nigerian Naira (cNGN)
‚Ä¢ buy usdc - Buy USD Coin
‚Ä¢ balance - Check your portfolio

*üí≥ Cards & Payments:*
‚Ä¢ my cards - View your cards
‚Ä¢ view card - See card details
‚Ä¢ send 1000 to alice.base.eth

*üè¶ Banking:*
‚Ä¢ add bank - Link Nigerian bank
‚Ä¢ withdraw 5000 - Cash out to bank

*üìä Account:*
‚Ä¢ history - View transactions
‚Ä¢ profile - Your account info

*üè∑Ô∏è Basename:*
‚Ä¢ set basename alice.base.eth
‚Ä¢ check basename alice.base.eth

Need help with anything specific? üí¨`;
    } catch (error) {
      logger.error("Error getting contextual help:", error);
      return MESSAGE_TEMPLATES.HELP;
    }
  }

  /**
   * Handle other methods with simple responses for now
   */
  private async handleSendMoney(user: any, data: any): Promise<string> {
    try {
      if (!data || !data.amount || !data.recipient) {
        return `üí∏ *Send Money*

Send crypto to anyone on Base network:

*Format:*
"send [amount] to [address/basename]"

*Examples:*
‚Ä¢ send 1000 to alice.base.eth
‚Ä¢ send 50 usdc to 0x1234...
‚Ä¢ send 100 to bob.base.eth

*Supported tokens:* cNGN, USDC`;
      }

      // Check KYC status
      const kycStatus = await UserService.getKYCStatus(user.id);
      if (!kycStatus.verified) {
        return `üîí *KYC Required for Transfers*

Complete KYC verification first to send money.

Type "submit kyc" to get started.`;
      }

      // Check PIN setup
      const hasPinSetup = await PinService.hasPinSetup(user.id);
      if (!hasPinSetup) {
        return `üîê *PIN Required for Transfers*

Set up your security PIN first to send money.

Type "setup pin" to secure your account.`;
      }

      const { amount, recipient, token = "cngn" } = data;

      // Validate amount
      const amountMatch = amount.match(/(\d+(?:\.\d+)?)/);
      if (!amountMatch) {
        return `‚ùå Invalid amount format.
Example: "send 1000 to alice.base.eth"`;
      }

      const amountValue = amountMatch[1];

      // Use secure transaction flow (requires PIN)
      return await FlowHandler.handleSecureTransaction(
        user.whatsappNumber,
        "SEND_MONEY",
        {
          amount: amountValue,
          recipient,
          token: token.toLowerCase(),
        },
        SessionManager.getSession(user.whatsappNumber)!
      );
    } catch (error) {
      logger.error("Error handling send money:", error);
      return MESSAGE_TEMPLATES.ERROR_GENERIC;
    }
  }

  private async handleDeposit(user: any): Promise<string> {
    return `üí∞ *Deposit Crypto*

Your wallet address:
\`${user.walletAddress}\`

You can:
1. Buy cNGN: "buy cngn"
2. Transfer from another wallet
3. Receive from friends

‚ö†Ô∏è Only send cNGN tokens to this address on Base network.`;
  }

  private async handleProfile(user: any): Promise<string> {
    try {
      const cardCount = await CardService.getCardCount(user.id);
      const kycStatus = await UserService.getKYCStatus(user.id);
      const hasPinSetup = await PinService.hasPinSetup(user.id);

      return `üë§ *Your Profile*

üì± WhatsApp: ${user.whatsappNumber}
üè∑Ô∏è Name: ${user.firstName || "Not set"} ${user.lastName || ""}
üí≥ Wallet Address:
\`${user.walletAddress}\`

üé¥ Cards: ${cardCount}
üÜî KYC: ${kycStatus.verified ? "‚úÖ Verified" : "‚ùå Not Verified"}
üîê PIN: ${hasPinSetup ? "‚úÖ Set Up" : "‚ùå Not Set Up"}
üè∑Ô∏è Basename: ${user.basename || "Not set"}
üìÖ Joined: ${new Date(user.createdAt).toLocaleDateString()}

*üí° Tip:* Tap and hold the wallet address to copy it

*Actions:*
‚Ä¢ Set basename: "set basename yourname.base.eth"
‚Ä¢ Check balance: "balance"
‚Ä¢ View cards: "my cards"`;
    } catch (error) {
      logger.error("Error getting profile:", error);
      return MESSAGE_TEMPLATES.ERROR_GENERIC;
    }
  }

  private async handleBuyUSDC(user: any, data: any): Promise<string> {
    try {
      const amount = data?.amount || "100"; // Default $100
      const amountNum = parseFloat(amount);

      // Validate amount
      if (amountNum < 10) {
        return "‚ùå Minimum purchase is $10 USDC";
      }

      if (amountNum > 10000) {
        return "‚ùå Maximum purchase is $10,000 USDC";
      }

      // Use OnRampService for USDC purchases
      const result = await OnRampService.initiateUSDCPurchase({
        userId: user.id,
        amountUSD: amountNum,
        paymentMethod: "CARD",
      });

      if (result.success) {
        return `üíµ *Buy ${amountNum} USDC*

üí∞ Cost: $${amountNum} USD
ü™ô You'll receive: ${amountNum} USDC
‚ö° Network: Base Sepolia
üîó Rate: 1 USD = 1 USDC

${result.paymentInstructions}

*What is USDC?*
USD Coin - A stable cryptocurrency backed 1:1 by US Dollars. Perfect for international transactions.`;
      } else {
        return `‚ùå Failed to initiate USDC purchase: ${result.error}

Try again with: "buy usdc"`;
      }

      return `üíµ *Buy ${amountNum} USDC*

üí∞ Cost: $${amountNum} USD
ü™ô You'll receive: ${amountNum} USDC
‚ö° Network: Base Sepolia
üîó Rate: 1 USD = 1 USDC

*Ready to purchase!*
Click the MoonPay link below to buy with your card:

*What is USDC?*
USD Coin - A stable cryptocurrency backed 1:1 by US Dollars. Perfect for international transactions.`;
    } catch (error) {
      logger.error("Error handling buy USDC:", error);
      return MESSAGE_TEMPLATES.ERROR_GENERIC;
    }
  }

  private async handleBuyUSDT(user: any, data: any): Promise<string> {
    return `üí∞ *USDT Not Available*

USDT is not deployed on Base Sepolia testnet yet.

*Available now:*
‚Ä¢ cNGN (Nigerian Naira): "buy cngn"
‚Ä¢ Check your balance: "balance"

*Why only cNGN?*
We're on Base Sepolia testnet where only cNGN is deployed.
USDC/USDT will be available when we move to mainnet.`;
  }

  private async handleSetBasename(user: any, data: any): Promise<string> {
    try {
      const basename = data?.basename;
      if (!basename) {
        return `üè∑Ô∏è *Set Your Basename*

Basenames are human-readable addresses on Base network.

*Current wallet:*
\`${user.walletAddress}\`

*Example:* "set basename alice.base.eth"

*Benefits:*
‚Ä¢ Easy to remember address
‚Ä¢ Receive payments with your name
‚Ä¢ Professional crypto identity

*Steps:*
1. Register at https://base.org/names
2. Set it here: "set basename yourname.base.eth"

*Format:* yourname.base.eth`;
      }

      // Validate basename format
      if (!BasenameService.isValidBasename(basename)) {
        return `‚ùå Invalid basename format.

*Correct format:* yourname.base.eth

*Examples:*
‚Ä¢ alice.base.eth ‚úÖ
‚Ä¢ john123.base.eth ‚úÖ
‚Ä¢ my-name.base.eth ‚úÖ

Try: "set basename yourname.base.eth"`;
      }

      // Check if basename is available
      const isRegistered = await BasenameService.isBasenameRegistered(basename);
      if (!isRegistered) {
        return `‚ùå Basename "${basename}" is not registered yet.

*Next steps:*
1. üåê Register at: https://base.org/names
2. üîó Connect wallet: ${user.walletAddress.slice(0, 10)}...
3. üí∞ Pay registration fee (usually ~$5)
4. ‚úÖ Come back: "set basename ${basename}"

*Why register?*
‚Ä¢ Own your Web3 identity
‚Ä¢ Easy payments & transfers
‚Ä¢ Professional crypto presence`;
      }

      // Update user basename
      const result = await UserService.updateBasename(user.id, basename);
      if (result) {
        return `üéâ *Basename Set Successfully!*

üè∑Ô∏è Your basename: ${basename}
üí≥ Wallet: ${user.walletAddress.slice(0, 10)}...${user.walletAddress.slice(-4)}
‚úÖ Verified and linked

*Now people can send you money using:*
"send 1000 to ${basename}"

*Much easier than:*
"send 1000 to ${user.walletAddress}"

Your Web3 identity is ready! üöÄ`;
      } else {
        return `‚ùå Failed to set basename.

*Possible issues:*
‚Ä¢ Basename doesn't belong to your wallet
‚Ä¢ Network connection error
‚Ä¢ Basename not fully registered

*Solutions:*
1. Verify ownership at https://base.org/names
2. Wait a few minutes and try again
3. Contact support if issue persists`;
      }
    } catch (error) {
      logger.error("Error setting basename:", error);
      return MESSAGE_TEMPLATES.ERROR_GENERIC;
    }
  }

  private async handleCheckBasename(data: any): Promise<string> {
    try {
      const basename = data?.basename;
      if (!basename) {
        return `üîç *Check Basename Availability*

Check if a basename is available:
"check basename alice.base.eth"

*What are basenames?*
Human-readable addresses on Base network
Example: alice.base.eth instead of 0x1234...`;
      }

      // Validate format
      if (!BasenameService.isValidBasename(basename)) {
        return `‚ùå Invalid basename format.

Please use: yourname.base.eth
Example: "check basename alice.base.eth"`;
      }

      // Check availability
      const isRegistered = await BasenameService.isBasenameRegistered(basename);

      if (isRegistered) {
        // Try to resolve to see who owns it
        const resolved = await BasenameService.resolveBasename(basename);

        return `‚úÖ *Basename "${basename}" is registered*

üè∑Ô∏è Name: ${basename}
üí≥ Owner: ${resolved.address?.slice(0, 10)}...${resolved.address?.slice(-4)}
‚úÖ Status: Active

This basename is already taken.
Try a different name or register a new one at https://base.org/names`;
      } else {
        return `üéâ *Basename "${basename}" is available!*

üè∑Ô∏è Name: ${basename}
‚úÖ Status: Available for registration

*Next steps:*
1. Register at https://base.org/names
2. Set it in Nelo: "set basename ${basename}"

*Why get a basename?*
‚Ä¢ Easy to remember address
‚Ä¢ Professional crypto identity
‚Ä¢ Receive payments with your name`;
      }
    } catch (error) {
      logger.error("Error checking basename:", error);
      return MESSAGE_TEMPLATES.ERROR_GENERIC;
    }
  }

  private async handleWithdraw(user: any, data: any): Promise<string> {
    try {
      // Check KYC status
      const kycStatus = await UserService.getKYCStatus(user.id);
      if (!kycStatus.verified) {
        return `üîí *KYC Required for Withdrawals*

Complete KYC verification first to withdraw funds.

Type "submit kyc" to get started.`;
      }

      // Check if user has bank account
      const bankAccounts = await UserService.getBankAccounts(user.id);
      if (bankAccounts.length === 0) {
        return `üè¶ *Bank Account Required*

Add a bank account first to withdraw funds.

Type "add bank" to link your Nigerian bank account.`;
      }

      const amount = data?.amount;
      if (!amount) {
        return `üí∏ *Withdraw cNGN to Bank*

Enter the amount you want to withdraw:
Example: "withdraw 5000"

*Available:*
‚Ä¢ Check balance: "balance"
‚Ä¢ Add bank: "add bank"
‚Ä¢ View banks: "my banks"`;
      }

      const amountNum = parseFloat(amount);
      if (amountNum < 100) {
        return `‚ùå Minimum withdrawal is ‚Ç¶100`;
      }

      // Use IntegratedOffRampService for withdrawal
      const result = await IntegratedOffRampService.withdrawCNGN({
        userId: user.id,
        amountCNGN: amountNum,
        bankAccountId: bankAccounts[0].id, // Use first bank account
      });

      if (result.success) {
        return `‚úÖ *Withdrawal Initiated*

üí∏ Amount: ${amountNum.toLocaleString()} cNGN
üè¶ Bank: ${bankAccounts[0].bankName}
üìã Account: ${bankAccounts[0].accountNumber}
‚è±Ô∏è Processing: ${result.estimatedTime}
üîó Reference: ${result.withdrawalReference}

Your money is on the way! üöÄ`;
      } else {
        return `‚ùå Withdrawal failed: ${result.error}`;
      }
    } catch (error) {
      logger.error("Error handling withdrawal:", error);
      return MESSAGE_TEMPLATES.ERROR_GENERIC;
    }
  }

  private async handleBankAccount(user: any): Promise<string> {
    try {
      const bankAccounts = await UserService.getBankAccounts(user.id);

      if (bankAccounts.length === 0) {
        return `üè¶ *No Bank Accounts Found*

Add a bank account to withdraw funds:

"add bank [Bank Name], account [Account Number], [Account Name]"

Example:
"add bank GTBank, account 0123456789, John Doe"`;
      }

      let response = `üè¶ *Your Bank Accounts*\n\n`;

      bankAccounts.forEach((account, index) => {
        response += `${index + 1}. ${account.bankName}
   Account: ${account.accountNumber}
   Name: ${account.accountName}
   Status: ${account.isVerified ? "‚úÖ Verified" : "‚è≥ Pending"}

`;
      });

      response += `*Actions:*
‚Ä¢ Withdraw: "withdraw 5000"
‚Ä¢ Add bank: "add bank [details]"
‚Ä¢ Check balance: "balance"`;

      return response;
    } catch (error) {
      logger.error("Error getting bank accounts:", error);
      return MESSAGE_TEMPLATES.ERROR_GENERIC;
    }
  }

  private async handleAddBank(user: any, data: any): Promise<string> {
    try {
      if (!data || !data.bankName) {
        return `üè¶ *Add Bank Account*

Please provide your bank details in this format:
"add bank [Bank Name], account [Account Number], [Account Name]"

Example:
"add bank GTBank, account 0123456789, John Doe"

*Supported Banks:*
‚Ä¢ GTBank, Access Bank, First Bank
‚Ä¢ Zenith Bank, UBA, Fidelity Bank
‚Ä¢ And all major Nigerian banks`;
      }

      const { bankName, accountNumber, accountName } = data;

      if (!bankName || !accountNumber || !accountName) {
        return `‚ùå Missing bank details. Please use this format:
"add bank [Bank Name], account [Account Number], [Account Name]"`;
      }

      // Mock bank code (in production, look up actual bank codes)
      const bankCode = "999"; // Mock code

      const result = await UserService.addBankAccount(
        user.id,
        accountNumber,
        bankName,
        bankCode,
        accountName
      );

      if (result.success) {
        return `‚úÖ *Bank Account Added Successfully!*

üè¶ Bank: ${bankName}
üìã Account: ${accountNumber}
üë§ Name: ${accountName}
‚úÖ Status: Verified

You can now:
‚Ä¢ Withdraw funds: "withdraw 5000"
‚Ä¢ View all banks: "my banks"
‚Ä¢ Check balance: "balance"`;
      } else {
        return `‚ùå Failed to add bank account: ${result.error}`;
      }
    } catch (error) {
      logger.error("Error adding bank account:", error);
      return MESSAGE_TEMPLATES.ERROR_GENERIC;
    }
  }

  private async handleCashOut(user: any, data: any): Promise<string> {
    // Cash out is same as withdraw
    return await this.handleWithdraw(user, data);
  }

  private async handleBuyWithBank(user: any, data: any): Promise<string> {
    try {
      const amount = data?.amount;
      if (!amount) {
        return `üè¶ *Buy with Bank Transfer*

Enter the amount you want to buy:
Example: "buy 10000"

*Available:*
‚Ä¢ cNGN (Nigerian Naira): 1 NGN = 1 cNGN
‚Ä¢ Minimum: ‚Ç¶100
‚Ä¢ Maximum: ‚Ç¶1,000,000`;
      }

      const amountNum = parseFloat(amount);

      // Validate amount
      if (amountNum < 100) {
        return "‚ùå Minimum purchase is ‚Ç¶100";
      }

      if (amountNum > 1000000) {
        return "‚ùå Maximum purchase is ‚Ç¶1,000,000";
      }

      // Use Flutterwave for bank transfers
      const result = await flutterwaveService.initiateBankTransfer({
        userId: user.id,
        amount: amountNum,
        currency: "NGN",
        email: `${user.whatsappNumber.replace("+", "")}@nelo.app`,
        phoneNumber: user.whatsappNumber,
        fullName: `${user.firstName || "User"} ${user.lastName || ""}`.trim(),
      });

      if (result.success) {
        return `üè¶ *Bank Transfer Initiated*

üí∞ Amount: ‚Ç¶${amountNum.toLocaleString()}
ü™ô You'll receive: ${amountNum.toLocaleString()} cNGN
üîó Rate: 1 NGN = 1 cNGN (no fees!)

${result.paymentInstructions}

*After completing the transfer:*
Type "paid ${amount}" to confirm your payment

‚ö†Ô∏è Transfer the exact amount: ‚Ç¶${amountNum.toLocaleString()}`;
      } else {
        return `‚ùå Failed to initiate bank transfer: ${result.error}

Try again with: "buy ${amount}"`;
      }
    } catch (error) {
      logger.error("Error handling buy with bank:", error);
      return MESSAGE_TEMPLATES.ERROR_GENERIC;
    }
  }

  private async handleConfirmPayment(user: any, data: any): Promise<string> {
    try {
      const amount = data?.amount;
      if (!amount) {
        return `‚ùå Please specify the amount you paid.
Example: "paid 10000"`;
      }

      // Use IntegratedOnRampService to confirm payment
      const { IntegratedOnRampService } = await import(
        "../payment/integratedOnRampService"
      );

      const result = await IntegratedOnRampService.confirmPayment({
        userId: user.id,
        amountNGN: parseFloat(amount),
        paymentReference: `nelo_deposit_${user.id}_${Date.now()}`,
      });

      if (result.success) {
        return `üéâ *Payment Confirmed!*

‚úÖ Amount: ‚Ç¶${parseFloat(amount).toLocaleString()} NGN
‚úÖ cNGN Received: ${parseFloat(amount).toLocaleString()} cNGN
‚úÖ Status: Completed

*Your wallet has been funded!*
‚Ä¢ Check balance: "balance"
‚Ä¢ Create card: "create card"
‚Ä¢ Send money: "send 1000 to alice.base.eth"

Welcome to Nelo! üöÄ`;
      } else {
        return `‚ùå Payment confirmation failed: ${result.error}

Please try again or contact support if you made the payment.`;
      }
    } catch (error) {
      logger.error("Error confirming payment:", error);
      return `‚ùå Payment confirmation failed. Please try again or contact support.`;
    }
  }

  private async handleResetPin(user: any): Promise<string> {
    try {
      const hasPinSetup = await PinService.hasPinSetup(user.id);
      if (!hasPinSetup) {
        return `‚ùå *No PIN Found*

You haven't set up a PIN yet.

Type "setup pin" to create your security PIN.`;
      }

      // Start PIN reset flow
      SessionManager.startFlow(user.whatsappNumber, "PIN_RESET");

      return `üîê *PIN Reset - Security Verification*

To reset your PIN, I need to verify your identity first.

Please answer your security question:

*This will be shown in the next step...*`;
    } catch (error) {
      logger.error("Error handling PIN reset:", error);
      return MESSAGE_TEMPLATES.ERROR_GENERIC;
    }
  }

  private handleCancel(): string {
    return `‚ùå *Operation Cancelled*

Type "help" to see available commands.`;
  }
}
